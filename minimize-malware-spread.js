// Given an adjacency matrix and initial nodes that are infected, return the first node from inital list to remove to minimize spread of infection

// https://leetcode.com/problems/minimize-malware-spread

function minMalwareSpread(graph, initial) {
  let adjacency = {};
  for (let row = 0; row < graph.length; row++) {
    adjacency[row] = [];
    for (let col = 0; col < graph[0].length; col++) {
      if (graph[row][col] === 1 && row !== col) {
        adjacency[row].push(col);
      }
    }
  }

  initial.sort((a, b) => a - b);
  let maxClear = 0;
  let maxIndex = initial[0];
  let initialSet = new Set(initial);
  let visitedSet;
  let count = 0;
  let connected = false;
  function _DFS(node) {
    count++;
    visitedSet.add(node);
    adjacency[node].forEach(v => {
      if (!visitedSet.has(v)) {
        if (initialSet.has(v)) {
          connected = true;
        } else {
          _DFS(v);
        }
      }
    });
  }

  for (let node of initial) {
    count = 0;
    connected = false;
    visitedSet = new Set();
    _DFS(node);
    if (!connected) {
      if (count > maxClear) {
        maxClear = count;
        maxIndex = node;
      }
    }
  }
  return maxIndex;
}

module.exports = minMalwareSpread;
